var fs = require('fs'),
	stat = fs.stat,
	path = require('path'),
	crypto = require('crypto'),
	url = require('url'),
	TEXT_FILE_EXTS = [
		'css', 'tpl', 'js', 'php',
		'txt', 'json', 'xml', 'htm',
		'text', 'xhtml', 'shtml', 'html', 'md',
		'conf', 'po', 'config', 'tmpl',
		'coffee', 'less', 'sass', 'jsp',
		'scss', 'manifest', 'bak', 'asp',
		'tmp', 'haml', 'jade', 'aspx',
		'ashx', 'java', 'py', 'c', 'cpp',
		'h', 'cshtml', 'asax', 'master',
		'ascx', 'cs', 'ftl', 'vm', 'ejs',
		'styl', 'jsx', 'handlebars'
	],
	IMAGE_FILE_EXTS = [
		'svg', 'tif', 'tiff', 'wbmp',
		'png', 'bmp', 'fax', 'gif',
		'ico', 'jfif', 'jpe', 'jpeg',
		'jpg', 'woff', 'cur', 'webp',
		'swf', 'ttf', 'eot'
	],
	MIME_MAP = {
		//text
		'css': 'text/css',
		'tpl': 'text/html',
		'js': 'text/javascript',
		'jsx': 'text/javascript',
		'php': 'text/html',
		'asp': 'text/html',
		'jsp': 'text/jsp',
		'txt': 'text/plain',
		'json': 'application/json',
		'xml': 'text/xml',
		'htm': 'text/html',
		'text': 'text/plain',
		'md': 'text/plain',
		'xhtml': 'text/html',
		'html': 'text/html',
		'conf': 'text/plain',
		'po': 'text/plain',
		'config': 'text/plain',
		'coffee': 'text/javascript',
		'less': 'text/css',
		'sass': 'text/css',
		'scss': 'text/css',
		'styl': 'text/css',
		'manifest': 'text/cache-manifest',
		//image
		'svg': 'image/svg+xml',
		'tif': 'image/tiff',
		'tiff': 'image/tiff',
		'wbmp': 'image/vnd.wap.wbmp',
		'webp': 'image/webp',
		'png': 'image/png',
		'bmp': 'image/bmp',
		'fax': 'image/fax',
		'gif': 'image/gif',
		'ico': 'image/x-icon',
		'jfif': 'image/jpeg',
		'jpg': 'image/jpeg',
		'jpe': 'image/jpeg',
		'jpeg': 'image/jpeg',
		'eot': 'application/vnd.ms-fontobject',
		'woff': 'application/font-woff',
		'ttf': 'application/octet-stream',
		'cur': 'application/octet-stream'
	};

function getIconv() {
	return require('iconv-lite');
}

var _ = module.exports = function () {

};

/*
 * log
 * */
_.log = require('./log.js');

/*
 * config
 * */
_.config = require('./config.js');

/*
 * 判断是否传递某个参数
 * */
_.hasArgv = function (argv, search) {
	var pos = argv.indexOf(search);
	var ret = false;
	while (pos > -1) {
		argv.splice(pos, 1);
		pos = argv.indexOf(search);
		ret = true;
	}
	return ret;
};

/*
 * 判断一个对象是否为数组
 * */
_.isArray = function (obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
};

/*
 * 判断一个元素是否在数组中
 * */
_.inArray = function (item, arr) {
	// 不是数组则跳出
	if (!_.isArray(arr)) {
		return false;
	}
	// 遍历是否在数组中
	for (var i = 0, k = arr.length; i < k; i++) {
		if (item == arr[i]) {
			return true;
		}
	}
	return false;
};

/*
 * 判断一个对象是否为 json
 * */
_.isJson = function (obj) {
	return typeof(obj) == "object" && Object.prototype.toString.call(obj).toLowerCase() == "[object object]" && !obj.length;
};

/*
 * 拷贝对象
 * */
_.extend = function (source, target) {
	if (typeof source === 'object' && typeof target === 'object') {
		for (var key in target) {
			if (target.hasOwnProperty(key)) {
				source[key] = _.extend(source[key], target[key]);
			}
		}
	} else {
		source = target;
	}
	return source;
};

/*
 * 补齐字符长度
 * */
_.pad = function (str, len, fill, pre) {
	if (str.length < len) {
		fill = (new Array(len)).join(fill || ' ');
		if (pre) {
			str = (fill + str).substr(-len);
		} else {
			str = (str + fill).substring(0, len);
		}
	}
	return str;
};

/*
 * MD5加密
 * */
_.md5 = function (data, len) {
	if ('number' === typeof data) {
		data = data.toString();
	}
	var md5sum = crypto.createHash('md5'),
		encoding = typeof data === 'string' ? 'utf8' : 'binary';
	md5sum.update(data, encoding);
	len = len || _.config.get('md5Length') || 32;
	return md5sum.digest('hex').substring(0, len);
};

/*
 * base64编码
 * */
_.base64 = function (data) {
	if (data instanceof Buffer) {
		//do nothing for quickly determining.
	} else if (data instanceof Array) {
		data = new Buffer(data);
	} else {
		//convert to string.
		data = new Buffer(String(data || ''));
	}
	return data.toString('base64');
};

/*
 * 文件是否存在
 * */
_.exists = fs.existsSync || path.existsSync;

/*
 * 获取文件类型
 * */
function getFileTypeReg(type) {
	var map = [], ext = _.config.get('fileType.' + type) || '';
	if (type === 'text') {
		map = TEXT_FILE_EXTS;
	} else if (type === 'image') {
		map = IMAGE_FILE_EXTS;
	} else {
		_.log.error('invalid file type [' + type + ']');
	}
	if (ext && ext.length) {
		if (typeof ext === 'string') {
			ext = ext.split(/\s*,\s*/);
		}
		map = map.concat(ext);
	}
	map = map.join('|');
	return new RegExp('\\.(?:' + map + ')$', 'i');
}

/*
 * 是否文本类型文件
 * */
_.isTextFile = function (path) {
	return getFileTypeReg('text').test(path || '');
};

/*
 * 是否为图片类型文件
 * */
_.isImageFile = function (path) {
	return getFileTypeReg('image').test(path || '');
};

/*
 * 转换编码
 * */
_.toEncoding = function (str, encoding) {
	return getIconv().toEncoding(String(str), encoding);
};

/*
 * 字节流是否为UTF8编码
 * */
_.isUtf8 = function (bytes) {
	var i = 0;
	while (i < bytes.length) {
		if ((// ASCII
			0x00 <= bytes[i] && bytes[i] <= 0x7F
			)) {
			i += 1;
			continue;
		}

		if ((// non-overlong 2-byte
			(0xC2 <= bytes[i] && bytes[i] <= 0xDF) &&
				(0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF)
			)) {
			i += 2;
			continue;
		}

		if (
			(// excluding overlongs
				bytes[i] == 0xE0 &&
					(0xA0 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
					(0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
				) || (// straight 3-byte
				((0xE1 <= bytes[i] && bytes[i] <= 0xEC) ||
					bytes[i] == 0xEE ||
					bytes[i] == 0xEF) &&
					(0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
					(0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
				) || (// excluding surrogates
				bytes[i] == 0xED &&
					(0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x9F) &&
					(0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
				)
			) {
			i += 3;
			continue;
		}

		if (
			(// planes 1-3
				bytes[i] == 0xF0 &&
					(0x90 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
					(0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
					(0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
				) || (// planes 4-15
				(0xF1 <= bytes[i] && bytes[i] <= 0xF3) &&
					(0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
					(0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
					(0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
				) || (// plane 16
				bytes[i] == 0xF4 &&
					(0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x8F) &&
					(0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
					(0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
				)
			) {
			i += 4;
			continue;
		}
		return false;
	}
	return true;
};

/*
 * 将二进制流转换为字符
 * */
_.readBuffer = function (buffer) {
	if (_.isUtf8(buffer)) {
		buffer = buffer.toString('utf8');
		if (buffer.charCodeAt(0) === 0xFEFF) {
			buffer = buffer.substring(1);
		}
	} else {
		buffer = getIconv().decode(buffer, 'gbk');
	}
	return buffer;
};

/*
 * 读取文件
 * */
_.read = function (path, convert) {
	var content = false;
	if (_.exists(path)) {
		content = fs.readFileSync(path);
		if (convert || _.isTextFile(path)) {
			content = _.readBuffer(content);
		}
	} else {
		_.log.error('unable to read file[' + path + ']: No such file or directory.');
	}
	return content;
};

/*
 * 读取JSON文件
 * */
_.readJSON = function (path) {
	var json = fs.readFileSync(path),
		result = {};
	try {
		result = JSON.parse(json);
	} catch (e) {
		console.error('parse json file[' + path + '] fail, error [' + e.message + ']');
	}
	return result;
};

/*
 * 打开浏览器
 * */
_.openURL = function (url) {
	var exec = require('child_process').exec;
	switch (process.platform) {
		case "darwin":
			exec('open ' + url);
			break;
		case "win32":
			exec('start ' + url);
			break;
		default:
			spawn('xdg-open', [url]);
		// I use `spawn` since `exec` fails on my machine (Linux i386).
		// I heard that `exec` has memory limitation of buffer size of 512k.
		// http://stackoverflow.com/a/16099450/222893
		// But I am not sure if this memory limit causes the failure of `exec`.
		// `xdg-open` is specified in freedesktop standard, so it should work on
		// Linux, *BSD, solaris, etc.
	}
};

/*
 * 复制文件夹
 * */
_.copyDir = function (src, dst, data) {
	// 读取目录中的所有文件/目录
	fs.readdir(src, function (err, paths) {
		if (err) {
			throw err;
		}
		paths.forEach(function (path) {
			var _src = src + '/' + path,
				_dst = dst + '/' + path,
				readable, writable;
			fs.stat(_src, function (err, st) {
				if (err) {
					throw err;
				}
				if (st.isFile()) {
					if (data && data.name) {
						_dst = _dst.replace(/{name}/i, data.name);
					}
					// 需要进行内部处理的文本类型文件
					if (/\.(css|js|json|htm|html|shtml|md|markdown)$/i.test(path)) {

						fs.readFile(_src, function (err, content) {
							content = content.toString();
							for (var key in data) {
								var re = new RegExp('{' + key + '}', 'g');
								content = content.replace(re, data[key]);
							}
							fs.writeFile(_dst, content);
						});

					} else {
						readable = fs.createReadStream(_src);
						writable = fs.createWriteStream(_dst);
						readable.pipe(writable);
					}

				} else if (st.isDirectory()) {
					var exists = fs.existsSync(_dst);
					if (!exists) {
						fs.mkdir(_dst, function () {
							_.copyDir(_src, _dst, data);
						});
					} else {
						_.copyDir(_src, _dst, data);
					}
				}
			});
		});
	});
};

/*
 * 根据本地时区返回Data对象
 * */

_.localDate = function () {
	var d = new Date();
	var localTime = d.getTime();
	var localOffset = parseInt(d.getTimezoneOffset() / 60);
	return new Date(localTime - localOffset * 3600000);
};

/*
 * 输出核心模块版本信息
 * */
_.version = function (pkgFile) {
	var pkg = _.readJSON(pkgFile);
	var content = [
		'v' + pkg.version
	];
	_.log.out(content.join('\n'));
};

_.changeTwoDecimal = function changeTwoDecimal(floatvar) {
	var f_x = parseFloat(floatvar);
	if (isNaN(f_x)) {
		return floatvar;
	}
	var f_x = Math.round(floatvar * 100) / 100;
	return f_x;
};

/*
 * 转换文件尺寸为短字符
 * */
_.formatFileSize = function (byteSize) {
	var size = parseInt(byteSize);
	if (size < 1024) {
		return size + ' B';
	} else if (size < 1024 * 1024) {
		return _.changeTwoDecimal(size / 1024) + ' KB';
	} else {
		return _.changeTwoDecimal(size / 1024 / 1024) + ' MB';
	}
};


