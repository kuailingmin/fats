var fs = require('fs'),
	stat = fs.stat,
	path = require('path'),
	crypto = require('crypto'),
	url = require('url');

var _ = module.exports = function () {

};

/*
 * 判断是否传递某个参数
 * */
_.hasArgv = function (argv, search) {
	var pos = argv.indexOf(search);
	var ret = false;
	while (pos > -1) {
		argv.splice(pos, 1);
		pos = argv.indexOf(search);
		ret = true;
	}
	return ret;
};

/*
 * 判断一个对象是否为数组
 * */
_.isArray = function (obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
};

/*
 * 判断一个元素是否在数组中
 * */
_.inArray = function (item, arr) {
	// 不是数组则跳出
	if (!_.isArray(arr)) {
		return false;
	}
	// 遍历是否在数组中
	for (var i = 0, k = arr.length; i < k; i++) {
		if (item == arr[i]) {
			return true;
		}
	}
	return false;
};

/*
 * 判断一个对象是否为 json
 * */
_.isJson = function (obj) {
	return typeof(obj) == "object" && Object.prototype.toString.call(obj).toLowerCase() == "[object object]" && !obj.length;
};

/*
 * 拷贝对象
 * */
_.extend = function (source, target) {
	if (typeof source === 'object' && typeof target === 'object') {
		for (var key in target) {
			if (target.hasOwnProperty(key)) {
				source[key] = _.extend(source[key], target[key]);
			}
		}
	} else {
		source = target;
	}
	return source;
};

/*
 * 补齐字符长度
 * */
_.pad = function (str, len, fill, pre) {
	if (str.length < len) {
		fill = (new Array(len)).join(fill || ' ');
		if (pre) {
			str = (fill + str).substr(-len);
		} else {
			str = (str + fill).substring(0, len);
		}
	}
	return str;
};

/*
 * MD5加密
 * */
_.md5 = function (data, len) {
	var md5sum = crypto.createHash('md5'),
		encoding = typeof data === 'string' ? 'utf8' : 'binary';
	md5sum.update(data, encoding);
	len = len || fats.config.get('project.md5Length', 7);
	return md5sum.digest('hex').substring(0, len);
};

/*
 * base64编码
 * */
_.base64 = function (data) {
	if (data instanceof Buffer) {
		//do nothing for quickly determining.
	} else if (data instanceof Array) {
		data = new Buffer(data);
	} else {
		//convert to string.
		data = new Buffer(String(data || ''));
	}
	return data.toString('base64');
};

/*
 * 读取JSON文件
 * */
_.readJSON = function (path) {
	var json = fs.readFileSync(path),
		result = {};
	try {
		result = JSON.parse(json);
	} catch (e) {
		console.error('parse json file[' + path + '] fail, error [' + e.message + ']');
	}
	return result;
};

/*
 * 打开浏览器
 * */
_.openURL = function (url) {
	var exec = require('child_process').exec;
	switch (process.platform) {
		case "darwin":
			exec('open ' + url);
			break;
		case "win32":
			exec('start ' + url);
			break;
		default:
			spawn('xdg-open', [url]);
		// I use `spawn` since `exec` fails on my machine (Linux i386).
		// I heard that `exec` has memory limitation of buffer size of 512k.
		// http://stackoverflow.com/a/16099450/222893
		// But I am not sure if this memory limit causes the failure of `exec`.
		// `xdg-open` is specified in freedesktop standard, so it should work on
		// Linux, *BSD, solaris, etc.
	}
};

_.copy = function( src, dst ){
    // 读取目录中的所有文件/目录
    fs.readdir(src, function( err, paths ){    	
        if(err){
            throw err;
        }  
         paths.forEach(function(_path){
            var _src = src + '/' + _path,
                _dst = dst + '/' + _path,
                readable, writable;         
             stat( _src, function( err, st ){
                if( err ){
                    throw err;
                } 
                 // 判断是否为文件
                if( st.isFile() ){
                    // 创建读取流
                    readable = fs.createReadStream( _src );
                    // 创建写入流
                    writable = fs.createWriteStream( _dst );   
                    // 通过管道来传输流
                    readable.pipe( writable );
                }
                // 如果是目录则递归调用自身
                else if( st.isDirectory() ){
                    _.exists( _src, _dst, _.copy );
                }
            });
            console.log(_path);
        });

    });
}; 
 // 在复制目录前需要判断该目录是否存在，不存在需要先创建目录
_.exists = function( src, dst, callback ){
    fs.exists( dst, function( exists ){
        // 已存在
        if( _.exists ){
            callback( src, dst );
        }
        // 不存在
        else{
            fs.mkdir( dst, function(){
                callback( src, dst );
            });
        }
    });
}; 